리액트 프로젝트 구성

nome_modules :  node.js 모듈이 설치되는 폴더. 리액트 프로젝트가 동작되는데 필요한 모듈이 설치되는 폴더
build 시 필요없는 부분은 자동 제외됨
public : 리액트 프로젝트의 기본 파일이 위치하는곳. index.html 파일에 있는 div 태그를 이액트로 조정하여 화면에 표시함

src :  리액트 프로젝트의 소스코드가 존재하는 폴더
index.js :  리액트 프로젝트의 시작점. 리액트 프로젝트 시작시 시 index.html 파일 안의 div 태그 중 id 값이 'root'인 태그를 검색하여 선태갛고 index.js를 로딩하여 index.js의 내용을 실행하여 화면을 구성

MPA : Multi Page Application의 줄임말. 웹 페이지가 여러개 있는 형태의 웹 사이트, 기존 방식의 웹 사이트
SPA : Single Page Application의 줄임말. 웹 페이지가 단 하나로 이루어진 웹 사이트. 자바 스크립트를 이용하여 필요에 따라서 웹 페이지를 새로 그려내는 사이트

Virtual DOM : 리액트에서 웹 페이지를 그려내기 위해서 사용하는 방식.
- 기본적으로 웹은 화면을 한번 출력하고 다시 수정된 화면을 출력 시 모든 화면을 다시 그려야함
- 화면을 재출력하기 위해서 새로 그리면 화면 깜빡임 현상이 발생함.
- 조금의 수정이 발생해도 모든 리소스를 다시 호출하기 때문에 리소스 성능이 떨어짐
- 리액트는 virtual Dom을 사용하여 실제 화면은 그대로 두고 가상돔의 내용만 먼저 수정하고 수정이 끝난 후 가상돔의 화면과 실제 화면을 교체하여 화면이 빠르게 로딩되는 것처럼 만들어 줌

리액트는 컴포넌트 기반으로 화면을 구성함
- 화면을 구성하는 부분부분을 뜻함
- jsp나 타임리프를 이용하여 여러 가지 파일을 하나로 합하여하나의 웹 페이지를 구성하는 것과 비슷함
- 재사용성이 높아짐

jsx : 리액트에서 사용하는 자바스크립트 확장 문법
- javascript + xml/html을 의미함
- 자바스크립트 변수에 html 태그를 그대로 사용하여 화면을 구성함
- xml 문법 규칙을 기본으로 하기 때문에 시작 태그와 끝 태그가 반드시 한 쌍으로 구성돼야 함
- 시작 태그의 마지막에 끝 태그를 뜻하는 /를 추가하면 시작태그만 있어도 상관없음
- <br></br>
- <hr/>
- render() 메소드의 return에 화면 그리기위한 html 태그 및 컴포넌트를 입력하여 화면을 구성
- render() 메소드의 return에 들어가는 태그가 1개일 경우 () 필요없음
- render() 메소드의 return에 들어가는 태그가 2개 이상일 경우 반드시 ()로 감싸야함
- render() 메소드의 return에 들어가는 부모태그는 반드시 1개 이어야..

day2
엘리먼트 : 리액트 앱의 가장 작은 빌드 블록
- 웹 페이지의 정보를 담고 있는 DOM에서 사용하는 용어(HTML 태그를 뜻함)
- 리액트에서는 엘리먼트를 리액트 엘리먼트라고 함
- 리액트는 가상돔을 사용하고 리액트 엘리먼트는 가상돔에 존재함
- 리엑트 엘리먼트는 DOM 엘리먼트의 가상 표현
- 리액트에서 엘리먼트는 자바스크립트의 object 타입으로 존재함
- createElemet() 함수가 생성함

엘리먼트의 특징: 엘리먼트는 생성 후에는 children인 attributes를 변경할 수 없음(불변성)
- 엘리먼트는 생성 후 변경할 수 없기 때문에 수정된 내용이 필요 시 새로 생성하여 바꿔치기함
- 이를 위해서 가상돔을 사용함

컴포넌트 : 리액트에서 화면을 구성하는 자바스크립트 클래스 혹은 함수
- 여러개의 컴포넌트를 레고 블럭처럼 사용하여 하나의 큰 화면을 구성함
- 개념적으로 자바스크립트 함수와 비슷함
- props를 입력받아 JSX 문법으로 화면을 구성하고 엘리먼트를 출력함
- 자바의 클래스와 객체의 관계와 비슷함

props : 리액트 컴포넌트의 속성
- 자바스크립트 object 타입으로 구성되어 있음
- 읽기 전용
- 데이터 전달:
    부모 컴포넌트에서 자식 컴포넌트 호출 시 전달할 속성명과 값을 함께 전달
    <Button 속성명1=속성값1, 속성명2=속성값2, ...></Button>
    문자열 데이터는 '', ""를 사용하여 데이터 전달
    문자열을 제외한 다른 데이터 타입은 반드시 {}를 사용하여 전달
    데이터를 사용하는 자식 컴포넌트에서는 props.속성명 형태로 사용함

reate2 프로젝트
컴포넌트 종류 : 리액트에서는 함수 컴포넌트와 클래스 컴포넌트로 두가지의 컴포넌트를 제공하고 있음
- 예전에는 클래스 컴포넌트를 사용했음
- 컴포넌트 생명주기를 사용할 수 있기 때문에 리액트의 모든 기능을 사용할 수 있음
- React.Component 클래스를 상속받아 사용하는 방식
- props, state의 사용시 구분이 힘든 부분이 존재하여 사용이 힘들었음
- 현재는 함수 컴포넌트를 주로 사용함
- 컴포넌트 생명주기에 관련된 함수를 사용할 수 없었기 때문에 기능에 제약이 있었음
- 리액트 16.8버전부터 Hooks 라는 기능이 추가되어 함수 컴포넌트에서도 모든 기능을 다 사용할 수 있도록 함

컴포넌트 합성 : 여러개의 컴포넌트를 합하여 하나의 컴포넌트로 만드는 것
컴포넌트 추출 : 하나의 컴포넌트에서 여러개의 컴포넌트로 분리하는 것


day3
state : 리액트 컴포넌트의 상태. 리액트 컴포넌트의 수정 가능한 데이터. 화면 ui 변경이 필요할 때
- 렌더링이나 데이터 흐름에 사용되는 값만 state에 포함해야 함
- JS object 타입으로 구성되어 있음
- state도 직접적인 병경이 불가능함 (setState()라는 함수를 사용하여 수정)
- 함수 컴포넌트에서는 hooks의 하나인 useState를 사용하여 수정
- 클래스 컴포넌트에서는 setState() 함수를 사용히ㅏㅁ

리액트에서 사용하는 데이터 - 2개
- props :  매개 변수 . 부모 컴포넌트에서 자식 컴포넌트로. 읽기 전용, 직접 변경 불가
- state : 현재 컴포넌트의 데이터 수정

리액트 생명주기 : 리액트 컴포넌트가 생성되고 수정되고 삭제될때 실행되는 과정
- 리액트 생명주기에 따라 3개의 메소드가 존재하고 실행됨
- componentDidMount(): 컴포넌트가 생성된 후 실행되는 메소드
- componentDidUpdate(): 컴포넌트의 내용이 수정된 후 실행되는 메소드, setState() 실행 시
- componentWillUnmount(): 컴포넌트가 삭제되기 직전에 실행되는 메소드, 부모 컴포넌트에서 더 이상 자식 컴포넌트를 사용하지 않을 경우

Hooks : 리액트의 특정 기능이 hook을 걸어서 해당 기능을 사용할 수 있도록 해주는 기능
- 함수 컴포넌트에는 원래 존재하지 않았던 생명주기 함수를 사용할 수 있도록 해주는 기능
- setState 기능을 사용할 수 있도록 해주는 기능
- custom hook을 사용하여 사용자가 필요한 기능을 추가로 생성하여 사용할 수 있음

useState : 클래스 컴포넌트의 setState를 사용할 수 있도록 하는 hook
- 사용법 : import React {useState} from 'react';
- const [변수명, set변수명] = useState(초기값);

useEffect : 클래스 컴포넌트의 생명주기 함수를 사용할 수 있도로고 하는 hook
- useEffect로 componentDidMount(), componentDidUpdate(), componentWillUnmount() 함수 기능 다 사용할 수 있음
- 의존성 배열로 지정된 변수의 값이 변경될 경우 지정한 콜백함수가 실행됨(componentDidUpdate() 기능)
- 의존성 배열의 내용을 빈 배열[]로 지정할 경우 컴포넌트 생성 후 지정된 콜백함수가 한번만 실행됨(componentDidMount() 기능)
- useEffect에서 return하는 함수는 컴포넌트가 해제될 때 실행됨(componentWillUnmount() 기능)
- 사용법 : import React {useEffect} from 'react';
- useEffect(이펙트 함수, 의존성 배열);

useRef : 특정 컴포넌트에 접근할 수 있도록 해주는 hook. 레퍼런스를 사용하기 위한 hook
- 레퍼런스란 리액트에서 특정 컴포넌트에 접근할 수 있는 개체를 의미
- 레터런스 객체는 current라는 속성이 존재하고 해당 속성은 현재 참고하고 있는 엘리먼트를 뜻함
- 특정 엘리먼트를 선택할 수 있음
- 사용법 : import React, {useRef} from 'react';
- const refContianer = useRef(초기값);

day4
hooks의 규칙 두가지
1. 무조건 최상위 레벨에서만 호출해야 함(해당 컴포넌트 내의 최상위 레벨)
- 반복문이나 조건문 혹은 중첩된 함수 안에서 실행해서는 안됨
- 컴포넌트가 렌더링될 때 매번 같은 순서로 호출되어야 함
2. 리액트 함수 컴포넌트에서만 훅을 호출해야 함
- 훅은 클래스 컴포넌트의 불편함을 해결하기 위해서 만들어짐
- 일반적 자바스크립트 함수에서 훅을 호출하면 안됨

커스텀 훅 : 리액트에서 제공하는 훅 이외의 기능이 필요할 경우 사용자가 직접 생성하여 사용할 수 있는 hook
- 여러 컴포넌트에서 반복적으로 사용해야 하는 로직을 hook을 만들어서 재사용하기 위해 사용함
- 사용법 :
- 컴포넌트의 이름에 접두사 'use'를 사용하고 내부에 다른 hook을 호출하는 자바스크립트 함수
- 'use'를 사용하지 않으면 특정 함수 내에서 훅을 사용하는지 알 수 없기 때문에 훅의 조건을 검사할 수 없음
- 커스텀 훅도 훅이기 때문에 훅의 조건이 그대로 적용됨

* 리액트 프로젝트 깃 다운로드 시 노드 모듈 없을 경우
터미널에서 현재 프로젝트 폴더로 이동 후 npm install 입력하면 노드 모듈 다운로드
구성편집에서 새 구성 추가 -> npm -> 스크립트 start 선택 / 자바스크립트 디버그 추가 localhost:3000

이벤트 사용하기 : 컴포넌트에 함수를 추가하고 JSX를 통한 UI에서 on이벤트 속성에 이벤트 발생 시 실행할 함수명을 입력하여 사용함
- 매개변수를 전달하고자 할 경우 on이벤트 속성에 콜백함수를 지정하고 콜백함수에서 지정한 함수를 실행하는 형태로 해야함
- 실행하는 함수에 매개변수를 입력하여 실행하면 됨

조건부 랜더링 : 어떠한 조건에 따라서 랜더링이 달라지는 것
자바스크립트의 Truthy와 Falsy : 자바스크립트에서 참과 거짓을 구분하는 데이터 타입인 논리형(bool) 타입은 값이 true, false로만 구성되어 있음
- 자바스크립트에서 true 및 false가 아니더라도 true 및 false로 여겨지는 값이 존재함
- 이러한 데이터 형태를 Truthy, Falsy라고 함
Truthy : true, [], {}, 0이 아닌 숫자데이터, 빈 문자열이 아닌 문자열
Falsy : false, 숫자 0, 실수 0.0, 빈 문자열, null, undefined, NaN

엘리먼트 변수 : 조건부 랜더링 시 레너링 해야할 컴포넌트를 변수처럼 사용하는 것
- let 변수명 = <컴포넌트명/>;
- {변수명}

인라인 조건문 : 조건문을 소스코드에 집어넣어서 사용하는 것. inline if, inline if ~ else
inline if : if문을 조건부 랜더링이 필요한 곳에 입력하여 사용하는 것
- 실제 if문이 아닌 AND(&&) 연산자를 사용하여 inline if를 구현함
- true && 조건식 -> 조건식의 결과
- false && 조건식 -> false
- Falsy && 조건식을 사용 시 뒤에 있는 조건 결과를 평가하지 않기 때문에 화면에 표시하지 않지만 Falsy값이 화면에 출력될 수 있음
inline if ~ else : if ~ else문을 조건부 랜더링이 필요한 곳에 입력하여 사용
- 실제 if ~ else문이 아닌 삼항연산자를 사용하여 구현함
- 조건문 ? 참일 경우 : 거짓일 경우

랜더링 막기 : 조건부 랜더링 사용 시 조건에 따라서 컴포넌트를 출력하지 않게 해야할 경우 null을 출력

day6
리스트 : 목록을 뜻하는 리스트, 자바스크립트에서는 배열을 뜻함
키 : 각 객체나 아이템을 구분할 수 있는 유일한 값

제어 컴포넌트 : 사용자가 입력한 값에 접근하고 제어할 수 있도록 해주는 컴포넌트
- 제어 컴포넌트는 그 값이 리액트의 통제를 받는 입력 폼 엘리먼트

shared state : 공유된 state, 자식 컴포넌트가 공통된 부모 컴포넌트의 state를 공유하여 사용하는 것
- 어떤 컴포넌트의 state에 있는 데이터를 여러 개의 자식 컴포넌트에서 공통적으로 사용하는 것

자식 컴포넌트의 state 가져오기
데이터의 전달 -> props 사용. 부모에서 자식으로 일방통행.

dya7
컴포넌트 합성 : 여러 개의 컴포넌트를 합쳐서 새로운 컴포넌트를 만드는 것
Containment : 하위 컴포넌트를 포함하는 형태의 합성 방식(포함)
Specialization : 범용적인 개념을 구별이 되도록 구체화하는 것(구체화)

컨텍스트 : 컴포넌트의 데이터를 컴포넌트 트리를 통해서 바로 원하는 컴포넌트에 전달하는 방식
React.createContext(기본값) : 컨텍스트 객체를 생성, 기본값 반드시 설정
- 컨텍스트 객체 하나에 하나의 데이터만 저장할 수 있음
- 배열 및 object 타입을 사용 시 여러 개의 데이터를 전달할 수 있음

Provider : 생성된 컨텍스트를 사용할 자식 컴포넌트를 지정
- value : 전달하고자 하는 데이터를 지정
- 여러개의 Providef를 사용하는 것이 가능함
- 사용법 :
<컨텍스트명.Provider value={전달할 데이터}>
    <자손 컴포넌트/>
</컨텍스트명.Provider>

Consumer : Provider로 감싸진 자손 컴포넌트 중 저장된 데이터를 사용하고자 할 경우 사용
- 여러개의 Consumer를 사용하는 것이 가능함
- 사용법:
<컨택스트명.Consumer>
    {value => <컴포넌트명 속성명={value}/>}
</컨택스트명.Consumer>

Context.displayName : 컨택스트의 이름을 지정할 때 사용함
- 개발자 도구의 Components 에서 displayName으로 지정한 이름이 출력됨
- <지정한 이름.Provider>, <지정한 이름.Consumer>
- 사용법 : 컨텍스트명.displayName = '사용하려는 이름';

useContext : 컨텍스트를 사용하기 위한 리액트의 hooks
- useContext를 사용하면 Consumer를 입력하지 않아도 됨
- 사용법 :
const 변수명 = useContext(컨텍스트명);

Axios : node.js에서 비동기 통신을 하기 위한 라이브러리. 내부적으로 promise를 사용함
- axios는 rest 방식 통신을 지원함
- get(url, config) : get 방식으로 서버에 데이터 요청
- post(url, data[ , config]) : post 방식으로 서버에 데이터 전달
- put(url, data[ , config]) : put 방식으로 서버에 데이터 전달
- delete(url, data[ , config]) : delete 방식으로 데이터 전달
- options(url, config]) : axios 객체 생성 시 설정 정보를 변경할 수 있음

- then() : 정상적으로 통신이 성공했을 경우 실행되는 콜백 함수
- catch() : 통신이 실패했을 경우 실행되는 콜백 함수

- async/awate와 함께 사용 시 then()이 필요할 경우 나중에 호출할 수 있음
- async/awate와 함께 사용 시 예외 처리를 try/catch로

응답 객체 : 요청에 대한 응답 객체가 json 방식으로 전달됨
- data{} : 서버에서 제공한 데이터, json 타입
- status : 서버와의 통신 응답 신호. 200 - ok, 300 - redirect, 400 - 리소스 없음, 500 - 서버 내부 오류
- statusText : 서버와의 응답 메시지
- headers{} : 서버에서 응답한 헤더 정보
- config{} : 서버에서 요청 시 axios의 설정 정보
- request{} : 응답을 생성한 요청

사용법 :
- npm install axios; // 사용할 프로젝트에 axios 라이브러리 추가
- import axios from 'axios'; // 사용할 컴포넌트에서 axios 라이브러리 임포트

- axios({
    method: 'get|post|put|delete',
    url: 'url',
    data: {
        param1: 'data1',
        param2: 'data2'
    },
});

- axios.get(url)
  .then(function(rep){
    성공시 실행할 소스 코드;
  })
  .catch(function(err){
    실패시 실행할 소스 코드;
  });

- axios.post(url, {
    param1: 'data1',
    param2: 'data2'
  })
  .then(function(rep){
    성공시 실행할 소스 코드;
  })
  .catch(function(err){
    실패시 실행할 소스 코드;
  });

day7
react-router-dom : 리액트에서 MPA 페이지처럼 구현할 수 잇도록 해주는 라이브러리